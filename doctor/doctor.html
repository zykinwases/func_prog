<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- Учебное пособие по выполнению задания &laquo;Доктор&raquo; -->
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Учебное пособие по выполнению задания «Доктор»</title>
<!-- <link href="http://sp.cs.msu.ru/courses/scheme/rss.xml" rel="alternate" title="RSS" type="application/rss+xml"> -->
<style type="TEXT/CSS" title="Основной стиль">
body {background-color: #F9FAFB;
	margin-top: 0em;
	margin-bottom: 0em;
	margin-left: 0em;
	margin-right: 0em}
a {font-family: Tahoma;
	color: #003399;
	text-decoration: none}
a.small {font-size: 8pt;
	font-weight: bold}
a.section {font-size: 10pt;
	font-weight: bold}
a:visited {color: #553399;}
p {text-indent: 0em;
	margin-top: 0em;
	margin-bottom: 0em;
	margin-left: 1em;
	margin-right: 1em;
	font-family: Tahoma, Lucida Console;
	color: #000000;
	font-size: 11pt}
p.news { color: #CC3333;
	text-align: left;
	font-size: 10pt}
p.titlenews { color: #000000;
	text-align: left;
	font-weight: bold;
	font-size: 10pt}
p.title { color: #000000;
	margin-left: 0.8em;
	font-size: 13pt}
p.memo { color: #6699CC;
	margin-left: 1.4em;
	font-size: 8pt;
	font-weight: bold}
p.small { color: #000000;
	margin-left: 0.4em;
    font-size: 8pt}
p.boldsmall { color: #000000;
	font-size: 8pt;
	font-weight: bold}
  </style>
<script async="" src="doctor_files/analytics.js"></script><script language="JavaScript" src="doctor_files/mail.js" type="text/javascript"></script></head>

<body text="#000000" bgcolor="#FFFFFF">
<!-- Начало верней строки -->
<table width="100%" cellspacing="0" cellpadding="0" border="0" align="center">
<tbody><tr>
<td colspan="1" valign="middle" height="17" bgcolor="#CAD9E6">
<p class="memo"><a href="http://sp.cmc.msu.ru/" class="small">Главная страница «</a> <a href="http://sp.cmc.msu.ru/info/" class="small">Информация «</a> <a href="http://sp.cmc.msu.ru/info/4/" class="small">4 курс «</a> <a href="http://sp.cmc.msu.ru/courses/funcprog" class="small">курс ФПScheme «</a>
</p></td>
</tr>
<tr bgcolor="#95C1EC">
<td height="20">
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tbody><tr>
<td height="20">
<p class="title">Учебное пособие по выполнению задания «Доктор»<!-- <a href="rss.xml"><img src="rssicon.png" border="0" alt="rss"></a> -->
</p></td>
</tr>
<tr valign="top" bgcolor="white">
<td><br>
<p>Набор упражнений в рамках общего задания «Доктор» первоначально был 
составлен канд. физ.-мат. наук Черновым А. В. более десяти лет тому 
назад. Предложенный им текст доступен онлайн <a href="http://ejudge.ru/study/5sem/doctor.pdf">[pdf]</a>. Затем в течение ряда лет задание обновлялось канд. физ.-мат. наук <a href="http://sp.cmc.msu.ru/staff/mvv.html">Малышко В. В.</a>. Результаты этих обновлений перед Вами.<br><br>
</p></td>
</tr>
<tr bgcolor="#95C1EC">
<td height="20">
<p class="title">Оглавление</p>
</td>
</tr>
<tr>
<td valign="top" bgcolor="white"><br>
<p>
<a href="#0">Введение</a><br>
1-й блок. <a href="#1">Упражнения с 1 по 4</a><br>
1.1. <a href="#11">Упражнение 1. Заготовка doctor.rkt</a><br>
1.2. <a href="#12">Упражнение 2. Рекурсивные и итеративные процессы</a><br>
1.3. <a href="#13">Упражнение 3. Функции высших порядков и списки</a><br>
1.4. <a href="#14">Упражнение 4. 3-я стратегия генерации ответов</a><br>
2-й блок. <a href="#2">Упражнения с 5 по 6</a><br>
2.1. <a href="#21">Упражнение 5. Многопользовательский «Доктор»</a><br>
2.2. <a href="#22">Упражнение 6. 4-я стратегия генерации ответов</a><br>
3-й блок. <a href="#3">Упражнение 7. Обобщённый reply</a><br>
<br>
</p></td>
</tr>
<tr bgcolor="#95C1EC">
<td height="20">
<p class="title"><a name="0"></a>Введение</p>
</td>
</tr>
<tr>
<td valign="top" bgcolor="white"><br>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«Доктор» (или 
ELIZA) -- это название программы, созданной Джозефом Вейценбаумом. Эта 
программа имитирует (или пародирует) психоаналитика, ведущего диалог с 
пациентом. Программа принимает реплики пациента (в виде списков 
символов) и генерирует ответные реплики (также в виде списков). Для 
простоты сокращена пунктуация в записи реплик. Исходный код ELIZA на 
языках LISP-семейства можно найти в Сети: <a href="https://github.com/apg/chatter/blob/master/eliza.scm">[html]</a>, <a href="http://jeffshrager.org/llisp/26.html">[html]</a>.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В рамках 
выполнения практического задания Вы создадите собственную версию 
«Доктора», которая основана на некоторых (но не всех!) идеях, лежащих в 
основе исходной программы.
<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Упражнения по «Доктору» делятся на 4 блока:<br>
1-й блок -- упражнения с 1 по 4. Максимальный балл -- 5.<br>
2-й блок -- упражнения 5 и 6. Максимальный балл -- 7.<br>
3-й блок -- упражнение 7. Максимальный балл -- 8.<br>
<br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Рекомендуется
 сдавать упражнения блоками. Датой сдачи блока считается дата последнего
 сданного упражнения из блока, при условии что код прислан вовремя. Во 
время сдачи программы будьте готовы ответить на вопросы по коду, а также
 по материалам лекций. Например, какой процесс порождает та или иная 
функция: итеративный или рекурсивный, как работает та или иная спецформа
 или функция (в том числе, функция, написанная Вами). Может быть 
предложено оценить эффективность фрагмента Вашего кода и улучшить её, 
переписав фрагмент.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После сдачи 
любого из блоков «Доктора» следует прислать код лектору. Если код не 
прислан в течение 7 дней после сдачи, по заданию аннулируется отметка о 
сдаче.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Версии 
программы 1-3 блоков следует составлять на подмножестве языка 
scheme/base (начинайте свой код с директивы #lang scheme/base). В них 
использование мутаторов (присваиваний и т. п.), мутируемых структур 
данных Racket, запрещено. Составленная в ходе выполнения упражнений, 
программа должна быть показана лектору в ходе офлайновой сдачи. При 
переходе от начальных упражнений к последующим код следует дописывать 
так, чтобы функциональность программы расширялась (то, что было раньше, 
не портить). Не следует сдавать несколько разных версий программы, 
каждая из которых решает только одно из упражнений.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Предполагается,
 что прошлые годы учёбы привили Вам навык оформления кода. Сдаваемый код
 должен быть оформлен должным образом: быть читаемым, сопровождаться 
содержательными и актуальными комментариями на русском языке.<br><br>
</p></td>
</tr>
<tr bgcolor="#95C1EC">
<td height="20">
<p class="title"><a name="1"></a>Блок 1. Упражнения с 1 по 4
</p></td>
</tr>
<tr>
<td valign="top" bgcolor="white">
<br>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="11"></a><i>Упражнение 1. Заготовка doctor.rkt</i><br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В документах ВК-группы <a href="http://vk.com/sp_scheme">[html]</a> найдите заготовку кода «Доктора» и скачайте её. На сайте <a href="http://download.racket-lang.org/">[html]</a>
 найдите дистрибутив среды Racket и установите её себе на компьютер. 
Запустите IDE Racket и откройте заготовку кода «Доктора». Запустите код в
 интерпретаторе (Ctrl+R или кнопкой Run). Проверьте, как он работает. 
Например, вводите реплики пациента из листинга (реплики отмечены **, но 
** не являются частью реплик):<br>
</p><pre>&gt; (visit-doctor 'ivan)
Hello, ivan!
(what seems to be the trouble?)
**(everyone hates me)
(you feel that everyone hates you)
**(whenever i enter a room no one will look me in the eye)
(please go on)
**(they laugh at me behind my back)
(you seem to think they laugh at you behind your back)
**(they get together and talk about how they hate me)
(please continue)
**(even my mother hates me)
( that even your mother hates you)
**(even when i was a baby she said i was ugly and stupid)
(many people have the same sorts of feelings)
**(she hit me all the time)
(please continue)
...
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«Доктор» отвечает
 на реплики пациента двумя способами, реализованными в нём. Первый 
способ заключается в замене в реплике пользователя всех местоимений 
первого лица (i, me, my, ...) на соответствующие местоимения второго 
лица (you, you, are, ...). Местоимения второго лица в реплике 
пользователя заменяются на местоимения первого. К полученной таким 
образом фразе спереди дописывается некоторое общее замечание, вроде <tt>why do you say that</tt> или <tt>you seem to think that</tt>.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Второй метод 
проще первого. Реплика пациента при построении ответа не используется. В
 качестве ответа «Доктор» выдаёт одну из заготовленных общих фраз, 
выбранную случайно: <tt>please continue</tt> или <tt>many people have the same sorts of feelings</tt>.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Какой из двух
 методов будет использован, решает случай. С равной вероятностью 
выбирается один из двух.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«Доктор» запускается вызовом его основной функции -- <tt>visit-doctor</tt>
 с указанием имени пациента в качестве значения параметра. В этой 
функции сначала выводится приветствие пациента, задаётся вопрос, 
приглашающий к обмену репликами, а затем вызывается функция <tt>doctor-driver-loop</tt>, реализующая цикл приёма реплик пациента и генерации ответов «Доктора».<br>
</p><pre>(define (visit-doctor name)
  (printf "Hello, ~a!\n" name)
  (print '(what seems to be the trouble?))
  (doctor-driver-loop name)
)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
В цикле происходит печать приглашения -- ** -- и чтение реплик пациента,
 каждая из которых является списком символов (пользователю следует 
вводить их в скобках). Если пациент говорит <tt>(goodbye)</tt>, 
происходит выход из цикла и завершение работы «Доктора». В противном 
случае, порождается ответная реплика в соответствии с одной из двух 
стратегий, описанных выше.<br>
</p><pre>(define (doctor-driver-loop name)
    (newline)
    (print '**) ; доктор ждёт ввода реплики пациента, приглашением к которому является **
    (let ((user-response (read)))
      (cond 
	    ((equal? user-response '(goodbye)) ; реплика '(goodbye) служит для выхода из цикла
             (printf "Goodbye, ~a!\n" name)
             (print '(see you next week)))
            (else (print (reply user-response)) ; иначе Доктор генерирует ответ, печатает его и продолжает цикл
                  (doctor-driver-loop name)
             )
       )
     )
)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Генерацию ответной реплики осуществляет функция <tt>reply</tt>, принимающая реплику пациента в качестве значения параметра.<br>
</p><pre>(define (reply user-response)
      (case (random 2)  ; с равной вероятностью выбирается один из двух способов построения ответа
          ((0) (qualifier-answer user-response)) ; 1й способ
          ((1) (hedge))  ; 2й способ
      )
)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вторая стратегия построения ответов реализована функцией <tt>hedge</tt>. Она случайно выбирает из
списка заготовленных реплик один элемент.<br>
</p><pre>(define (hedge)
       (pick-random '((please go on)
                       (many people have the same sorts of feelings)
                       (many of my patients have told me the same thing)
                       (please continue)
                       )
         )
)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Случайный выбор одного из элементов списка реализует функция <tt>pick-random</tt>.<br>
</p><pre>(define (pick-random lst)
  (list-ref lst (random (length lst)))
)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Первая стратегия построения ответов реализована функцией <tt>qualifier-answer</tt>,
 получающей реплику пациента в качестве значения параметра. В ней 
случайно выбирается одно из заготовленных начал ответа. Окончанием 
ответа является реплика пользователя, в которой заменены лица.<br>
</p><pre>define (qualifier-answer user-response)
        (append (pick-random '((you seem to think that)
                               (you feel that)
                               (why do you believe that)
                               (why do you say that))
                )
                (change-person user-response)
        )
)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Замену лиц осуществляет функция <tt>change-person</tt>. Она вызывает более универсальную функцию <tt>many-replace</tt>,
 получающую список замен и список, в котором следует произвести замены. 
Она проверяет каждый элемент изменяемого списка, на возможность его 
замены. Если замена возможна (элемент найден в списке замен, то она 
производится, а окончание ответа находится при помощи рекурсивного 
вызова. Список замен является ассоциативным списком. Он составлен из 
подсписков, каждый из которых начинается с элемента-ключа и продолжается
 элементом-значением. Поиск подсписка по ключу выполняет стандартная 
функция <tt>assoc</tt>. Обратите внимание, что в <tt>if</tt> используется результат вызова <tt>assoc</tt>, который не всегда будет логическим значением. Убедитесь, что Вы верно понимаете как работают <tt>if</tt> и <tt>assoc</tt>.<br>
</p><pre>(define (many-replace replacement-pairs lst)
        (cond ((null? lst) lst)
              (else (let ((pat-rep (assoc (car lst) replacement-pairs))) ; Доктор ищет первый элемент списка в ассоциативном списке замен
                      (cons (if pat-rep (cadr pat-rep) ; если поиск был удачен, то в начало ответа Доктор пишет замену
                                (car lst) ; иначе в начале ответа помещается начало списка без изменений
                            )
                            (many-replace replacement-pairs (cdr lst)) ; рекурсивно производятся замены в хвосте списка
                        )
                     )
               )
         )
)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Задание упражнения 1.</i> Измените функции <tt>qualifier-answer</tt> и <tt>hedge</tt>, добавив в каждую не менее трёх новых заготовленных фраз-реплик и/или фраз, с которых начинается ответ с заменой лица.<br>
<br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="12"></a><i>Упражнение 2. Рекурсивные и итеративные процессы</i><br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Рассмотрим код функции <tt>many-replace</tt>.
 В ней с рекурсивным вызовом связаны остаточные вычисления. 
Следовательно, процесс, порождаемый при вычислении вызова этой функции, 
-- рекурсивный. Можно переписать <tt>many-replace</tt> так, чтобы процесс стал итеративным и вычисления занимали меньше памяти за счёт хвостовой рекурсии.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Задание упражнения 2.</i> Напишите новую версию функции <tt>many-replace</tt> с хвостовой рекурсией и вызовите её в теле <tt>change-person</tt>. Составьте код нового <tt>many-replace</tt> без определения локальной вспомогательной функции, а с использованием "именованного" <tt>let</tt>.
 Далее всякий раз, когда для реализации итеративного процесса 
понадобится локальная вспомогательная функция, используйте вместо неё 
"именованный" <tt>let</tt>. Новая версия функции должна быть эффективной. Если Вы планируете использовать <tt>append</tt> для "сборки" результата, то оцените сложность решения. Как получить ответ без <tt>append</tt>?<br><br>

</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="13"></a><i>Упражнение 3. Функции высших порядков и списки</i><br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Рассмотрим ещё раз реализацию <tt>many-replace</tt>. Она осуществляет отображение списка <tt>lst</tt> в список-результат. Общую схему подобной обработки списка реализует функция <tt>map</tt>.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Задание упражнения 3.</i> Напишите ещё одну версию функции <tt>many-replace</tt> и замените вызов в теле <tt>change-person</tt>. Сделайте так, чтобы тело новой версии состояло только из вызова <tt>map</tt>. Дополнительную функцию не определяйте отдельно, а заведите как анонимную -- результат вычисления спецформы <tt>lambda</tt>.
 Переписанная функция должна быть столь же эффективной, как результат 
выполнения упражнения 2. В ходе дальнейшей работы над «Доктором» всякий 
раз, когда описываете обработку списка, сделайте это с помощью 
подходящей функции высшего порядка (<tt>map</tt>, <tt>foldl</tt>, <tt>foldr</tt>, <tt>filter</tt>, <tt>andmap</tt>, <tt>ormap</tt> ...). В модуле, подключаемом директивой <tt>(require racket/list)</tt> есть дополнительные функции высшего порядка для работы со списками (<tt>filter-map</tt>, <tt>count</tt>, <tt>append-map</tt>, <tt>filter-not</tt>, <tt>argmin</tt>, <tt>argmax</tt>, <tt>remf</tt>, <tt>remf*</tt>, ...), имейте это в виду.<br><br>

</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="13"></a><i>Упражнение 4. 3-я стратегия генерации ответов</i><br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Двух способов
 генерации ответов мало. Добавим третий. «Доктор» может запоминать все 
реплики пациента и в ходе беседы возвращаться к сказанному пациентом 
ранее. В этом случае реплика «Доктора» будет начинаться со слов <tt>earlier you said that</tt>,
 а затем будет следовать одна из предыдущих реплик пациента, в которой 
выполнена замена лица. Например, если из предыдущих реплик пациента 
выбрана реплика <tt>(you are not being very helpful to me)</tt>, то по ней будет построен ответ <tt>(earlier you said that i am not being very helpful to you)</tt>.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Задание упражнения 4.</i> Измените программу таким образом, чтобы <tt>doctor-driver-loop</tt> сохранял список всех
реплик пользователя. Замечание: не используйте присваивания (мутаторы вроде <tt>set!</tt>). В этом нет необходимости. Новая версия функции <tt>reply</tt> будет выбирать одну стратегию из трёх. Новую стратегию реализуйте как отдельную функцию <tt>history-answer</tt>. Обратите внимание, что <tt>hedge</tt> и <tt>qualifier-answer</tt> можно применять всегда, а <tt>history-answer</tt>
 -- только при наличии предыдущих реплик. Когда пациент вводит первую 
реплику, эта стратегия не применима. Учтите это в реализации. Для 
случайного выбора из трёх альтернатив следует взять случайное число от 0
 до 2: <tt>(random 3)</tt>, и использовать его как номер выбранной 
стратегии, считая, что они нумеруются с нуля. Для вызова стратегии по 
выбранному номеру подходит спецформа <tt>case</tt>.<br><br>
</p></td>
</tr>
<tr bgcolor="#95C1EC">
<td height="20">
<p class="title"><a name="2"></a>Блок 2. Упражнения 5 и 6
</p></td>
</tr>
<tr>
<td valign="top" bgcolor="white"><br>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="21"></a><i>Упражнение 5. Многопользовательский «Доктор»</i><br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Текущая 
версия программы умеет работать только с одним пациентом, имя которого 
задаётся в вызове функции <tt>visit-doctor</tt>. Когда пациент говорит <tt>goodbye</tt>, <tt>visit-doctor</tt>
 возвращает управление интерпретатору. Измените программу таким образом,
 чтобы «Доктор» автоматически переходил к приёму следующего пациента 
после прощания с предыдущим. Предусмотрите способ завершения работы 
многопользовательского «Доктора» или после использования стоп-слова в 
качестве имени очередного пациента, или при исчерпании количества 
принимаемых пациентов. Стоп-слово и максимальное количество пациентов 
передаются в обновлённый <tt>visit-doctor</tt> как значения его параметров. Например, <tt>(visit-doctor 'suppertime 3)</tt> может завершиться либо если трое пациентов обслужено, либо если введено имя пациента <tt>suppertime</tt>. Для ввода имени очередного пациента можете воспользоваться функцией <tt>ask-patient-name</tt> (заметьте, что именем пациента считается первый элемент списка, введённого пользователем):<br>
</p><pre>(define (ask-patient-name)
 (begin
  (println '(next!))
  (println '(who are you?))
  (print '**)
  (car (read))
 ) 
)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Теперь сессия работы «Доктора» может выглядеть следующим образом:<br>
</p><pre>&gt; (visit-doctor 'suppertime 3)
(next!)
(who are you?) 
**(hal abelson)
(hello, hal)
(what seems to be the trouble?)
**(everyone taking 6.001 hates me)
(why do you say everyone taking 6.001 hates you)
...
**(goodbye)
(goodbye, hal)
(see you next week)
(next!)
(who are you?)
**(eric grimson)
(hello, eric)
(what seems to be the trouble?)
...
**(goodbye)
(goodbye, eric)
(see you next week)
(next!)
(who are you?)
**(suppertime)
(time to go home)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="22"></a><i>Упражнение 6. 4-я стратегия генерации ответов</i><br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Реализуйте 
ещё одну стратегию генерации ответных реплик, зависящую от ключевых слов
 в реплике пациента. Например, на фразу <tt>i am often depressed</tt> «Доктор» может ответить <tt>when you feel depressed, go out for ice cream</tt>.
 Структура данных, хранящая группы ключевых слов и привязанных к ним 
шаблонов для составления ответных реплик должна выглядеть так:<br>
</p><pre>( 
  ( ; начало данных 1й группы
    (depressed suicide exams university) ; список ключевых слов 1й группы
    ( ; список шаблонов для составления ответных реплик 1й группы 
	  (when you feel depressed, go out for ice cream)
      (depression is a disease that can be treated)
	)
  ) ; завершение данных 1й группы
  ( ; начало данных 2й группы ...
    (mother father parents brother sister uncle ant grandma grandpa)
    (
	  (tell me more about your * , i want to know all about your *)
      (why do you feel that way about your * ?)
	)
  )
  (
    (university scheme lections)
	(
	  (your education is important)
	  (how many time do you spend to learning ?)
	)
  )
)
</pre>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Можно видеть, что
 в разные группы ключевых слов могут входить одни и те же слова. Если в 
варианте ответной реплики есть звёздочка, это значит, что в ответе 
вместо <tt>*</tt> «Доктор» укажет ключевое слово, по которому он построил реплику. Например, на фразу пользователя, содержащую слово <tt>father</tt> может быть дан ответ <tt>tell me more about your father , i want to know all about your father</tt>.<br><br>
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Задание упражнения 6.</i>
 Реализуйте в программе стратегию построения ответов по ключевым словам.
 Пополните набор групп ключевых слов (не менее чем двумя новыми 
группами). Пополните варианты ответов для каждой группы (не менее чем 
двумя вариантами). Построение реплик по ключевым словам должно быть 
реализовано так, чтобы можно было вносить изменения только в структуру 
данных, не исправляя код функции, составляющей реплику. Реализуйте 
случайный выбор ключевого слова для построения реплики, если этих слов 
несколько во фразе пользователя. Этот выбор должен учитывать количество 
вхождений слова в реплику пациента. Когда выбор ключевого слова сделан, 
по нему следует выбрать один из подходящих шаблонов для составления 
ответной реплики. Предусмотрите учёт ситуации, когда одно и то же 
ключевое слово относится к разным группам. Для таких слов следует 
выбирать шаблон из объединённого перечня всех шаблонов, относящихся к 
каждой группе, куда входит ключевое слово. В выбранном шаблоне следует 
заменить <tt>*</tt> на ключевое слово. При этом следует использовать ту 
реализацию замен, которая уже есть в коде «Доктора». Поскольку 
построение реплики является обработкой списка, напишите код с 
использованием уместных функций высшего порядка (<tt>map</tt>, <tt>foldl</tt>, <tt>foldr</tt>, <tt>filter</tt>, <tt>andmap</tt>, <tt>ormap</tt> ...). 
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Стратегия 
построения реплики по ключевым словам применима только в том случае, 
когда в реплике есть какое-то ключевое слово. Следует описать отдельную 
функцию-предикат, проверяющую это. Функция-предикат должна быть 
эффективной. Она не должна делать лишних действий, после того как 
становится ясно, что стратегия применима. Если для работы 
функции-предиката не нужна вся структура данных, хранящая группы 
ключевых слов и привязанных к ним шаблонов, то следует однократно 
предобработать её, получив необходимые данные, и затем использовать 
результат однократной предобработки в вызовах функции-предиката.<br><br>
</p></td>
</tr>
<tr bgcolor="#95C1EC">
<td height="20">
<p class="title"><a name="3"></a>Блок 3. Упражнение 7. Обобщённый <tt>reply</tt>
</p></td>
</tr>
<tr>
<td valign="top" bgcolor="white"><br>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждый раз при добавлении новой стратегии приходилось переписывать <tt>reply</tt>.
 Можно переписать его, создав обобщённую версию, которая будет работать с
 любым подаваемым ему на вход перечнем стратегий. Удобство обобщённого <tt>reply</tt>
 состоит в том, что при изменении стратегий построения ответных реплик 
будет достаточно менять сами данные о стратегиях, но не управляющий 
механизм. Этот универсальный механизм состоит в следующем: во-первых, 
строится список стратегий, применимых в текущей ситуации; во-вторых, 
если в построенном списке больше одной стратегии, то выбирается одна из 
них; в-третьих, выбранная стратегия применяется и её результат будет 
ответной репликой. На вход механизма подаётся структура данных со 
сведениями обо всех стратегиях «Доктора». Про каждую стратегию в этой 
структуре хранится: а) функция-предикат от реплики пользователя, от 
истории реплик пользователя, от, возможно, других параметров, которая 
возвращает <tt>#t</tt>, только если стратегия применима, и <tt>#f</tt> 
-- иначе (Внимание! Должна храниться именно функция!); б) вес стратегии 
-- натуральное число, которое будет использовано при выборе одной из 
применимых стратегий (чем больше вес, тем выше вероятность применения 
стратегии, например, если есть применимые стратегии с весами 2, 3, 1, то
 первая будет выбрана с вероятностью 1/3, вторая -- с вероятностью 1/2, 
третья -- с вероятностью 1/6); тело стратегии -- функция, которая по 
реплике пользователя, по истории реплик пользователя, по, возможно, 
другим параметрам строит ответную реплику (Внимание! Должна храниться 
именно функция!). Например, для стратегии <tt>"hedge"</tt> функция-предикат -- это функция всегда возвращающая <tt>#t</tt>; вес этой стратегии = 1 (самый малый);  тело этой стратегии -- функция <tt>hedge</tt>.
</p><p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Выполняя упражнение 7, следует переписать <tt>reply</tt>,
 добавив ему параметр -- структуру данных о стратегиях построения 
реплик. Все стратегии ответов, имеющиеся в программе должны быть 
представлены в этой структуре данных. Каких-либо способов построения 
ответов вне структуры данных о стратегиях быть не должно. Структура 
данных о стратегиях не зависит от реплик пользователей и её значение не 
должно вычисляться более чем один раз. Так как речь снова идёт об 
обработке списков, пишите код с использованием уместных функций высшего 
порядка (<tt>map</tt>, <tt>foldl</tt>, <tt>foldr</tt>, <tt>filter</tt>, <tt>andmap</tt>, <tt>ormap</tt> ...). Назначая веса стратегиям, используйте разные значения веса, чтобы взвешенный поиск не превращался в случайный -- <tt>pick-random</tt>. Рекомендуется реализовать аналог <tt>pick-random</tt> -- <tt>pick-random-with-weight</tt>,
 который получает список элементов, имеющих веса, и выбирает случайный 
элемент с учётом весов. Рекомендуется перед реализацией «геометрически» 
решить задачу, т. е. рассмотреть случайный выбор части из составного 
отрезка (длина части отрезка = весу соответствующего элемента списка).<br><br>
</p></td>
</tr>
<tr bgcolor="#E3E9EC">
<td height="20">
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tbody><tr>
<td height="20">
<p class="title">Предупреждение
</p></td>
<td height="20" align="right">
<p class="boldsmall"><!--  -->
</p></td>
</tr>
</tbody></table>
</td>
</tr>
<tr>
<td valign="top" bgcolor="white"><br>
<p>Размещение на других ресурсах, а также коммерческое использование 
материалов, опубликованных в данном разделе, возможно только с 
разрешения авторов. По всем вопросам пишите: <a href="javascript:gotoEmail('vvmalyshko[at]gmail[dot]com')">&nbsp;<script language="JavaScript" type="text/javascript"><!--//
document.write(replaceMail("vvmalyshko[at]gmail[dot]com"))
//--></script>vvmalyshko@gmail.com&nbsp;</a><br><br>
</p></td>
</tr>
<!-- Конец блока -->
<tr bgcolor="#E3E9EC">
<td>

<p><a href="javascript:gotoEmail('webmaster[at]sp[dot]cs[dot]msu[dot]ru')">&nbsp;<script language="JavaScript" type="text/javascript"><!--//
document.write(replaceMail("webmaster[at]sp[dot]cs[dot]msu[dot]ru"))
//--></script>webmaster@sp.cs.msu.ru&nbsp;</a></p>
<p>© Кафедра системного программирования ВМК МГУ.</p>
<p>Обновлено: 12.II.2020</p>
</td>
</tr>
</tbody></table>
<!-- Google Analytics --> <script language="JavaScript" type="text/javascript"> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-4772600-6', 'auto'); ga('send', 'pageview'); </script> <!-- End Google Analytics -->


</td></tr></tbody></table></body></html>