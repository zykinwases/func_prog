#lang scheme/base

(require scheme/string)

(define input "train/text.txt")
(provide (all-defined-out))

(define forward-freq (make-hash))
(define forward-ngramm (make-hash))
(define reverse-freq (make-hash))
(define reverse-ngramm (make-hash))
(define n 4)

(define (train-graphs file)
  (let ((in (open-input-file file)))
    (let reader ((line (read-line in)))
      (if (eof-object? line) (println "Everything is ready")
          (begin (let ((sentences (parse-line line)))
                   (map add-to-frw-freq sentences)
                   (map add-to-frw-ngramms sentences)
                   (map add-to-rev-freq sentences)
                   (map add-to-rev-ngramms sentences)
                   )
                 (reader (read-line in))
                 )
          )
      )
    )
  )
  
(define (parse-line line)
  (map (lambda (sent)
         (reverse (cons "." (reverse (filter non-empty-string? (string-split sent #px"\\s*\\b\\s*"))))))
       (string-split (string-replace (string-downcase line)
                                     #px"[^a-z\\.\\?!;,:'\\s\\-]+"      
                                     ""
                                     #:all? #t)
                     #px"\\.|\\?|!")
       )
  )

(define (add-to-frw-freq sent)
  (let ((n-1-gramm (make-n-gramm sent (sub1 n))))
    (if (hash-has-key? forward-freq n-1-gramm)
        (hash-set! forward-freq n-1-gramm (add1 (hash-ref forward-freq n-1-gramm)))
        (hash-set! forward-freq n-1-gramm 1)
        )
   )
  )

(define (add-to-frw-ngramms sent)
  (let loop ((rev-n-gramm (make-n-gramm sent n)) (rest sent))
    (begin
      (let ((n-1-gramm (cdr rev-n-gramm)) (last-word (car rev-n-gramm)))
        (if (hash-has-key? forward-ngramm n-1-gramm)
            (let ((next-words-hash (hash-ref forward-ngramm n-1-gramm)))
              (if (hash-has-key? next-words-hash last-word)
                  (hash-set! next-words-hash last-word (add1 (hash-ref next-words-hash last-word)))
                  (hash-set! next-words-hash last-word 1)
                  )
              )
            (hash-set! forward-ngramm n-1-gramm (make-hash (list (cons last-word 1))))
            )
        )
      (if (> (length rest) n) (loop (make-n-gramm (cdr rest) n) (cdr rest))
          (void)
          )
      )
    )
  )

(define (add-to-rev-freq sent)
  (let ((n-1-gramm (make-n-gramm (cdr (reverse sent)) (sub1 n))))
    (if (hash-has-key? reverse-freq n-1-gramm)
        (hash-set! reverse-freq n-1-gramm (add1 (hash-ref reverse-freq n-1-gramm)))
        (hash-set! reverse-freq n-1-gramm 1)
        )
   )
  )

(define (add-to-rev-ngramms sent)
  (let ((rev-sent (cdr (reverse (cons "." sent)))))
    (let loop ((rev-n-gramm (make-n-gramm rev-sent n)) (rest rev-sent))
      (begin
        (let ((n-1-gramm (cdr rev-n-gramm)) (last-word (car rev-n-gramm)))
          (if (hash-has-key? reverse-ngramm n-1-gramm)
              (let ((next-words-hash (hash-ref reverse-ngramm n-1-gramm)))
                (if (hash-has-key? next-words-hash last-word)
                    (hash-set! next-words-hash last-word (add1 (hash-ref next-words-hash last-word)))
                    (hash-set! next-words-hash last-word 1)
                    )
                )
              (hash-set! reverse-ngramm n-1-gramm (make-hash (list (cons last-word 1))))
              )
          )
        (if (> (length rest) n) (loop (make-n-gramm (cdr rest) n) (cdr rest))
            (void)
            )
        )
      )
    )
  )

;перевёрнутая н-грамма
(define (make-n-gramm sent n)
  (let loop ((i n) (cur sent) (res '()))
    (if (or (= i 0) (null? cur)) res
        (loop (sub1 i) (cdr cur) (cons (car cur) res))
     )
   )
  )

(define (make-all-ngramms sent n)
  (let loop ((rest sent) (res '()))
    (if (< (length rest) n) res
        (loop (cdr rest) (cons (make-n-gramm rest n) res))
     )
   )
  )

(define (pick-random-from-hash hash-list)
  (let ((full-weight (foldl (lambda (elem res) (+ (cdr elem) res)) 0 hash-list))) 
    (let choose ((remaining (random full-weight)) (tail hash-list))
      (if (> (cdar tail) remaining) (caar tail)
          (choose (- remaining (cdar tail)) (cdr tail))
       )
      )
    )
  )

(define (forward-generation initial)
  ;(let ((initial (pick-random-from-hash (hash->list forward-freq))))
    (let gener ((cur-n-1gramm initial) (res initial) (iter 50))
      (if (or (eq? (car res) ".") (not (hash-has-key? forward-ngramm cur-n-1gramm)) (= iter 0))
          (reverse res)
          (let ((new-word (pick-random-from-hash (hash->list (hash-ref forward-ngramm cur-n-1gramm)))))
            (gener (cons new-word (reverse (cdr (reverse cur-n-1gramm)))) (cons new-word res) (sub1 iter))
             )
       )
      )
   ;)
  )

(define (reverse-generation initial)
  ;(let ((initial (pick-random-from-hash (hash->list reverse-freq))))
    (let gener ((cur-n-1gramm initial) (res initial) (iter 50))
      (if (or (eq? (car res) ".") (not (hash-has-key? reverse-ngramm cur-n-1gramm)) (= iter 0))
          (cdr res)
          (let ((new-word (pick-random-from-hash (hash->list (hash-ref reverse-ngramm cur-n-1gramm)))))
            (gener (cons new-word (reverse (cdr (reverse cur-n-1gramm)))) (cons new-word res) (sub1 iter))
             )
       )
      )
   ;)
  )

(define (mixed-generation sentence)
  (let ((extendable-n-1gramms (filter (lambda (ngramm) (or (hash-has-key? forward-ngramm ngramm) (hash-has-key? reverse-ngramm (reverse ngramm))))
                                     (make-all-ngramms sentence (sub1 n)))))
    (if (null? extendable-n-1gramms) (forward-generation (pick-random-from-hash (hash->list forward-freq)))
        (let ((n-1gramm (list-ref extendable-n-1gramms (random (length extendable-n-1gramms)))))
          (append (if (hash-has-key? reverse-ngramm (reverse n-1gramm))
                      (reverse-generation (reverse n-1gramm))
                      (reverse n-1gramm))
                  (if (hash-has-key? forward-ngramm n-1gramm)
                      (let without-first-i ((sent (forward-generation n-1gramm)) (i (sub1 n)))
                        (if (= i 0) sent
                            (without-first-i (cdr sent) (sub1 i))
                            )
                        )
                      (reverse n-1gramm))
                  )
          )
        )
   )
  )

(train-graphs input)
(define out (open-output-file "train/res.txt" #:exists 'replace))
(write reverse-ngramm out)
(write forward-ngramm out)
(close-output-port out)